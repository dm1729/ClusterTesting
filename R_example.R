# Simple R script to run on CPU cluster

## Simple Metropolis Hastings. Code mostly generated by ChatGPT

library(doParallel)
library(ggplot2)

# Define the target distribution (i.e. the distribution you want to sample from)
target <- function(x) {
  # Example: target distribution is a mixture of Gaussians
  dnorm(x, mean = -3, sd = 1) + dnorm(x, mean = 3, sd = 1)
}

# Define the proposal distribution
proposal <- function(x) {
  # Example: proposal distribution is a normal distribution with mean equal to the current value of x, and a fixed standard deviation of 0.5
  rnorm(1, mean = x, sd = 0.5)
}

# Run the Metropolis-Hastings algorithm
metropolis_hastings <- function(n_iterations,x_init=0){
  x <- x_init
  samples <- rep(NA, n_iterations)
  for (i in 1:n_iterations) {
    # Generate a proposal
    x_proposed <- proposal(x)

    # Calculate the acceptance probability
    alpha <- min(1, (target(x_proposed) * proposal(x)) / (target(x) * proposal(x_proposed)))

    # Generate a uniform random number
    u <- runif(1)

    # Accept or reject the proposal
    if (u < alpha) {
      x <- x_proposed
    }

    # Store the sample
    samples[i] <- x
  }
  return(samples)
}

iters_per_core <- 10000
max_cores <- parallel::detectCores()
num_cores <- min(16, max_cores)
doParallel::registerDoParallel(cores=num_cores)

parallel_chains <- foreach(i = 1 : num_cores)%dopar%{
  metropolis_hastings(n_iterations = iters_per_core)
}

doParallel::stopImplicitCluster()

plotting_dir <- ''

for (i in 1:num_cores){
  # create histogram of draws, trace plot etc.
  # save with different names
  data <- parallel_chains[[i]]

  # Create the histogram using ggplot
  plot <- ggplot(data = data.frame(data), aes(x = data)) +
    geom_histogram(binwidth = 0.5) +
    ggtitle(paste("Histogram of draws from Chain",i))

  # Save the plot to a specified directory
  ggsave(paste0(plotting_dir,"R_plot_",i,".png"), plot)
}

